{"version":3,"sources":["meteor://ðŸ’»app/packages/xinranxiao_spotify-web-api/spotify-api.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H","file":"/packages/xinranxiao_spotify-web-api.js","sourcesContent":["var Future = Npm.require(\"fibers/future\");\n\nSpotifyWebApi = function(config) {\n  config = config || {};\n  var SpotifyWebApi = Npm.require('spotify-web-api-node');\n  var api = new SpotifyWebApi(config);\n\n  // Set the access token + refresh token (either provided, or retrieved from account)\n  setAccessTokens(api, config);\n\n  // Create a refresh method that updates everything after the refresh.\n  api.refreshAndUpdateAccessToken = function(callback) {\n    var response = api.refreshAccessToken();\n\n    if (response.error) {\n      callback(response.error, null);\n    } else {\n      // Update the current API instance\n      api.setAccessToken(response.data.body.access_token);\n\n      // Update the current user (if available)\n      if (Meteor.userId()) {\n        Meteor.users.update({ _id: Meteor.userId() }, { $set: {\n          'services.spotify.accessToken': response.data.body.access_token,\n          'services.spotify.expiresAt': (+new Date) + (1000 * response.data.body.expires_in)\n        }});\n      }\n\n      callback(null, response);\n    }\n  }\n\n  // Whitelist functions to be wrapped. This is ugly -- any alternatives?\n  SpotifyWebApi.whitelistedFunctionNames = ['refreshAndUpdateAccessToken','getTrack','getTracks','getAlbum',\n    'getAlbums','getArtist','getArtists','searchAlbums',\n    'searchArtists','searchTracks','searchPlaylists','getArtistAlbums','getAlbumTracks','getArtistTopTracks',\n    'getArtistRelatedArtists','getUser','getMe','getUserPlaylists','getPlaylist','getPlaylistTracks','createPlaylist',\n    'followPlaylist','unfollowPlaylist','changePlaylistDetails','addTracksToPlaylist','removeTracksFromPlaylist',\n    'removeTracksFromPlaylistByPosition','replaceTracksInPlaylist','reorderTracksInPlaylist','clientCredentialsGrant',\n    'authorizationCodeGrant','refreshAccessToken','getMySavedTracks','containsMySavedTracks',\n    'removeFromMySavedTracks','addToMySavedTracks','followUsers','followArtists','unfollowUsers','unfollowArtists',\n    'isFollowingUsers','areFollowingPlaylist','isFollowingArtists', 'getFollowedArtists', 'getNewReleases','getFeaturedPlaylists',\n    'getCategories','getCategory','getPlaylistsForCategory', 'removeFromMySavedAlbums', 'addToMySavedAlbums', 'getMySavedAlbums', 'containsMySavedAlbums'];\n\n  // Wrap all the functions to be able to be called synchronously on the server.\n  _.each(SpotifyWebApi.whitelistedFunctionNames, function(functionName) {\n    var fn = api[functionName];\n    if (_.isFunction(fn)) {\n      api[functionName] = wrapAsync(fn, api);\n    }\n  });\n\n  return api;\n};\n\n/*\n  This is exactly the same as Meteor.wrapAsync except it properly returns the error.\n  credit goes to @faceyspacey -- https://github.com/meteor/meteor/issues/2774#issuecomment-70782092\n */\nvar wrapAsync = function(fn, context) {\n  return function (/* arguments */) {\n    var self = context || this;\n    var newArgs = _.toArray(arguments);\n    var callback;\n\n    for (var i = newArgs.length - 1; i >= 0; --i) {\n      var arg = newArgs[i];\n      var type = typeof arg;\n      if (type !== \"undefined\") {\n        if (type === \"function\") {\n          callback = arg;\n        }\n        break;\n      }\n    }\n\n    if(!callback) {\n      var fut = new Future();\n      callback = function(error, data) {\n        fut.return({error:  error, data: data});\n      };\n\n      ++i;\n    }\n\n    newArgs[i] = Meteor.bindEnvironment(callback);\n    var result = fn.apply(self, newArgs);\n    return fut ? fut.wait() : result;\n  };\n};\n\nvar setAccessTokens = function(api, config) {\n  var serviceConfiguration = ServiceConfiguration.configurations.findOne({service: 'spotify'});\n  if (config.clientId && config.clientSecret) {\n    api.setClientId(config.clientId);\n    api.setClientSecret(config.clientSecret);\n  } else if (serviceConfiguration) {\n    api.setClientId(serviceConfiguration.clientId);\n    api.setClientSecret(serviceConfiguration.secret);\n  } else {\n    throw new Error(\"No clientId/secret found. Please configure the `service-configuration` package.\");\n  }\n\n  if (config.accessToken) {\n    api.setAccessToken(config.accessToken);\n    if (config.refreshToken) {\n      api.setRefreshToken(config.refreshToken);\n    }\n  } else {\n    var currUser = Meteor.user();\n    if (currUser && currUser.services && currUser.services.spotify && currUser.services.spotify.accessToken) {\n      api.setAccessToken(currUser.services.spotify.accessToken);\n      if (currUser.services.spotify.refreshToken) {\n        api.setRefreshToken(currUser.services.spotify.refreshToken);\n      }\n    } else {\n      // No token specified\n      throw new Error(\"No accessToken found. Please provide an accessToken or login with xinranxiao:accouns-spotify\");\n    }\n  }\n}\n"]}